# Copyright (c) 2012-2019, Mark Peek <mark@peek.org>
# All rights reserved.
#
# See LICENSE file for full license.
#
# *** Do not modify - this file is autogenerated ***
# Resource specification version: 16.0.0


from . import AWSObject
from . import AWSProperty
from troposphere import Tags
from .validators import boolean
from .validators import integer

VALID_LISTENERTLS_MODE = ('STRICT', 'PERMISSIVE', 'DISABLED')


def validate_listenertls_mode(listenertls_mode):
    """Validate Mode for ListernerTls"""

    if listenertls_mode not in VALID_LISTENERTLS_MODE:
        raise ValueError("ListernerTls Mode must be one of: %s" %
                         ", ".join(VALID_LISTENERTLS_MODE))
    return listenertls_mode


class EgressFilter(AWSProperty):
    props = {
        'Type': (str, True),
    }


class MeshSpec(AWSProperty):
    props = {
        'EgressFilter': (EgressFilter, False),
    }


class Mesh(AWSObject):
    resource_type = "AWS::AppMesh::Mesh"

    props = {
        'MeshName': (str, True),
        'Spec': (MeshSpec, False),
        'Tags': (Tags, False),
    }


class Duration(AWSProperty):
    props = {
        'Unit': (str, True),
        'Value': (integer, True),
    }


class GrpcRetryPolicy(AWSProperty):
    props = {
        'GrpcRetryEvents': ([str], False),
        'HttpRetryEvents': ([str], False),
        'MaxRetries': (integer, True),
        'PerRetryTimeout': (Duration, True),
        'TcpRetryEvents': ([str], False),
    }


class WeightedTarget(AWSProperty):
    props = {
        'VirtualNode': (str, True),
        'Weight': (integer, True),
    }


class GrpcRouteAction(AWSProperty):
    props = {
        'WeightedTargets': ([WeightedTarget], True),
    }


class MatchRange(AWSProperty):
    props = {
        'End': (integer, True),
        'Start': (integer, True),
    }


class GrpcRouteMetadataMatchMethod(AWSProperty):
    props = {
        'Exact': (str, False),
        'Prefix': (str, False),
        'Range': (MatchRange, False),
        'Regex': (str, False),
        'Suffix': (str, False),
    }


class GrpcRouteMetadata(AWSProperty):
    props = {
        'Invert': (boolean, False),
        'Match': (GrpcRouteMetadataMatchMethod, False),
        'Name': (str, True),
    }


class GrpcRouteMatch(AWSProperty):
    props = {
        'Metadata': ([GrpcRouteMetadata], False),
        'MethodName': (str, False),
        'ServiceName': (str, False),
    }


class GrpcTimeout(AWSProperty):
    props = {
        'Idle': (Duration, False),
        'PerRequest': (Duration, False),
    }


class GrpcRoute(AWSProperty):
    props = {
        'Action': (GrpcRouteAction, True),
        'Match': (GrpcRouteMatch, True),
        'RetryPolicy': (GrpcRetryPolicy, False),
        'Timeout': (GrpcTimeout, False),
    }


class HttpRetryPolicy(AWSProperty):
    props = {
        'HttpRetryEvents': ([str], False),
        'MaxRetries': (integer, True),
        'PerRetryTimeout': (Duration, True),
        'TcpRetryEvents': ([str], False),
    }


class HttpRouteAction(AWSProperty):
    props = {
        'WeightedTargets': ([WeightedTarget], True),
    }


class HeaderMatchMethod(AWSProperty):
    props = {
        'Exact': (str, False),
        'Prefix': (str, False),
        'Range': (MatchRange, False),
        'Regex': (str, False),
        'Suffix': (str, False),
    }


class HttpRouteHeader(AWSProperty):
    props = {
        'Invert': (boolean, False),
        'Match': (HeaderMatchMethod, False),
        'Name': (str, True),
    }


class HttpRouteMatch(AWSProperty):
    props = {
        'Headers': ([HttpRouteHeader], False),
        'Method': (str, False),
        'Prefix': (str, True),
        'Scheme': (str, False),
    }


class HttpTimeout(AWSProperty):
    props = {
        'Idle': (Duration, False),
        'PerRequest': (Duration, False),
    }


class HttpRoute(AWSProperty):
    props = {
        'Action': (HttpRouteAction, True),
        'Match': (HttpRouteMatch, True),
        'RetryPolicy': (HttpRetryPolicy, False),
        'Timeout': (HttpTimeout, False),
    }


class TcpRouteAction(AWSProperty):
    props = {
        'WeightedTargets': ([WeightedTarget], True),
    }


class TcpTimeout(AWSProperty):
    props = {
        'Idle': (Duration, False),
    }


class TcpRoute(AWSProperty):
    props = {
        'Action': (TcpRouteAction, True),
        'Timeout': (TcpTimeout, False),
    }


class RouteSpec(AWSProperty):
    props = {
        'GrpcRoute': (GrpcRoute, False),
        'Http2Route': (HttpRoute, False),
        'HttpRoute': (HttpRoute, False),
        'Priority': (integer, False),
        'TcpRoute': (TcpRoute, False),
    }


class Route(AWSObject):
    resource_type = "AWS::AppMesh::Route"

    props = {
        'MeshName': (str, True),
        'MeshOwner': (str, False),
        'RouteName': (str, True),
        'Spec': (RouteSpec, True),
        'Tags': (Tags, False),
        'VirtualRouterName': (str, True),
    }


class TlsValidationContextAcmTrust(AWSProperty):
    props = {
        'CertificateAuthorityArns': ([str], True),
    }


class TlsValidationContextFileTrust(AWSProperty):
    props = {
        'CertificateChain': (str, True),
    }


class TlsValidationContextTrust(AWSProperty):
    props = {
        'ACM': (TlsValidationContextAcmTrust, False),
        'File': (TlsValidationContextFileTrust, False),
    }


class TlsValidationContext(AWSProperty):
    props = {
        'Trust': (TlsValidationContextTrust, True),
    }


class ClientPolicyTls(AWSProperty):
    props = {
        'Enforce': (boolean, False),
        'Ports': ([integer], False),
        'Validation': (TlsValidationContext, True),
    }


class ClientPolicy(AWSProperty):
    props = {
        'TLS': (ClientPolicyTls, False),
    }


class VirtualServiceBackend(AWSProperty):
    props = {
        'ClientPolicy': (ClientPolicy, False),
        'VirtualServiceName': (str, True),
    }


class Backend(AWSProperty):
    props = {
        'VirtualService': (VirtualServiceBackend, False),
    }


class BackendDefaults(AWSProperty):
    props = {
        'ClientPolicy': (ClientPolicy, False),
    }


class HealthCheck(AWSProperty):
    props = {
        'HealthyThreshold': (integer, True),
        'IntervalMillis': (integer, True),
        'Path': (str, False),
        'Port': (integer, False),
        'Protocol': (str, True),
        'TimeoutMillis': (integer, True),
        'UnhealthyThreshold': (integer, True),
    }


class ListenerTimeout(AWSProperty):
    props = {
        'GRPC': (GrpcTimeout, False),
        'HTTP': (HttpTimeout, False),
        'HTTP2': (HttpTimeout, False),
        'TCP': (TcpTimeout, False),
    }


class ListenerTlsAcmCertificate(AWSProperty):
    props = {
        'CertificateArn': (str, True),
    }


class ListenerTlsFileCertificate(AWSProperty):
    props = {
        'CertificateChain': (str, True),
        'PrivateKey': (str, True),
    }


class ListenerTlsCertificate(AWSProperty):
    props = {
        'ACM': (ListenerTlsAcmCertificate, False),
        'File': (ListenerTlsFileCertificate, False),
    }


class ListenerTls(AWSProperty):
    props = {
        'Certificate': (ListenerTlsCertificate, True),
        'Mode': (validate_listenertls_mode, True),
    }


class PortMapping(AWSProperty):
    props = {
        'Port': (integer, True),
        'Protocol': (str, True),
    }


class Listener(AWSProperty):
    props = {
        'HealthCheck': (HealthCheck, False),
        'PortMapping': (PortMapping, True),
        'TLS': (ListenerTls, False),
        'Timeout': (ListenerTimeout, False),
    }


class FileAccessLog(AWSProperty):
    props = {
        'Path': (str, True),
    }


class AccessLog(AWSProperty):
    props = {
        'File': (FileAccessLog, False),
    }


class Logging(AWSProperty):
    props = {
        'AccessLog': (AccessLog, False),
    }


class AwsCloudMapInstanceAttribute(AWSProperty):
    props = {
        'Key': (str, True),
        'Value': (str, True),
    }


class AwsCloudMapServiceDiscovery(AWSProperty):
    props = {
        'Attributes': ([AwsCloudMapInstanceAttribute], False),
        'NamespaceName': (str, True),
        'ServiceName': (str, True),
    }


class DnsServiceDiscovery(AWSProperty):
    props = {
        'Hostname': (str, True),
    }


class ServiceDiscovery(AWSProperty):
    props = {
        'AWSCloudMap': (AwsCloudMapServiceDiscovery, False),
        'DNS': (DnsServiceDiscovery, False),
    }


class VirtualNodeSpec(AWSProperty):
    props = {
        'BackendDefaults': (BackendDefaults, False),
        'Backends': ([Backend], False),
        'Listeners': ([Listener], False),
        'Logging': (Logging, False),
        'ServiceDiscovery': (ServiceDiscovery, False),
    }


class VirtualNode(AWSObject):
    resource_type = "AWS::AppMesh::VirtualNode"

    props = {
        'MeshName': (str, True),
        'MeshOwner': (str, False),
        'Spec': (VirtualNodeSpec, True),
        'Tags': (Tags, False),
        'VirtualNodeName': (str, True),
    }


class VirtualRouterListener(AWSProperty):
    props = {
        'PortMapping': (PortMapping, True),
    }


class VirtualRouterSpec(AWSProperty):
    props = {
        'Listeners': ([VirtualRouterListener], True),
    }


class VirtualRouter(AWSObject):
    resource_type = "AWS::AppMesh::VirtualRouter"

    props = {
        'MeshName': (str, True),
        'MeshOwner': (str, False),
        'Spec': (VirtualRouterSpec, True),
        'Tags': (Tags, False),
        'VirtualRouterName': (str, True),
    }


class VirtualNodeServiceProvider(AWSProperty):
    props = {
        'VirtualNodeName': (str, True),
    }


class VirtualRouterServiceProvider(AWSProperty):
    props = {
        'VirtualRouterName': (str, True),
    }


class VirtualServiceProvider(AWSProperty):
    props = {
        'VirtualNode': (VirtualNodeServiceProvider, False),
        'VirtualRouter': (VirtualRouterServiceProvider, False),
    }


class VirtualServiceSpec(AWSProperty):
    props = {
        'Provider': (VirtualServiceProvider, False),
    }


class VirtualService(AWSObject):
    resource_type = "AWS::AppMesh::VirtualService"

    props = {
        'MeshName': (str, True),
        'MeshOwner': (str, False),
        'Spec': (VirtualServiceSpec, True),
        'Tags': (Tags, False),
        'VirtualServiceName': (str, True),
    }


class VirtualGatewayListener(AWSProperty):
    """
    VirtualGatewayListener for VirtualGatewaySpec
    Same as Listener but without the Timeout property as per doc reference.
    """
    props = {
        'HealthCheck': (HealthCheck, False),
        'PortMapping': (PortMapping, True),
        'TLS': (ListenerTls, False),
    }


class VirtualGatewaySpec(AWSProperty):
    """
    VirtualGatewaySpec for VirtualGateway
    """
    props = {
        "BackendDefaults": (BackendDefaults, False),
        "Listeners": ([VirtualGatewayListener], True),
        "Logging": (Logging, False)
    }


class VirtualGateway(AWSObject):
    """
    Class to create AWS::AppMesh::VirtualGateway
    """
    resource_type = "AWS::AppMesh::VirtualGateway"
    props = {
        "MeshName": (str, True),
        "MeshOwner": (str, False),
        "Spec": (VirtualGatewaySpec, True),
        "Tags": ([Tags], False),
        "VirtualGatewayName": (str, True)
    }


class GatewayHttpRouteMatch(AWSProperty):
    """
    GatewayHttpRouteMatch for GatewayHttpRoute
    """
    props = {
        'Prefix': (str, True),
    }


class GatewayRouteVirtualService(AWSProperty):
    """
    GatewayRouteVirtualService for GatewayRouteTarget
    """
    props = {
        "VirtualServiceName": (str, True)
    }


class GatewayRouteTarget(AWSProperty):
    """
    Gateway Target for GatewayHttpRouteAction
    """

    props = {
        "VirtualService": (GatewayRouteVirtualService, True)
    }


class GatewayHttpRouteAction(AWSProperty):
    """
    GatewayHttpRouteAction for GatewayHttpRoute
    """
    props = {
        'Target': (GatewayRouteTarget, True)
    }


class GatewayHttpRoute(AWSProperty):
    """
    HTTP route for Appmesh Gateway HTTP Route Spec
    """
    props = {
            'Action': (GatewayHttpRouteAction, True),
            'Match': (GatewayHttpRouteMatch, True)
        }


class GatewayGrpcRouteMatch(AWSProperty):
    """
    GatewayGrpcRouteMatch for GatewayGrpcRoute
    """
    props = {
        'ServiceName': (str, False),
    }


class GatewayGrpcRouteAction(AWSProperty):
    """
    GatewayGrpcRouteAction for GatewayGrpcRoute
    """
    props = {
        'WeightedTargets': (GatewayRouteTarget, True),
    }


class GatewayGrpcRoute(AWSProperty):
    """
    GatewayGrpcRoute for GatewayRouteSpec
    """
    props = {
        'Action': (GatewayGrpcRouteAction, True),
        'Match': (GatewayGrpcRouteMatch, True)
    }


class GatewayRouteSpec(AWSProperty):
    """
    GatewayRouteSpec for GatewayRoute
    """
    props = {
        'GrpcRoute': (GatewayGrpcRoute, False),
        'Http2Route': (GatewayHttpRoute, False),
        'HttpRoute': (GatewayHttpRoute, False)
    }


class GatewayRoute(AWSObject):
    """
    Class to construct AWS::AppMesh::GatewayRoute
    """
    resource_type = "AWS::AppMesh::GatewayRoute"
    props = {
      "GatewayRouteName": (str, True),
      "MeshName": (str, True),
      "MeshOwner": (str, False),
      "Spec": (GatewayRouteSpec, True),
      "Tags": ([Tags], False),
      "VirtualGatewayName": (str, True)
    }
